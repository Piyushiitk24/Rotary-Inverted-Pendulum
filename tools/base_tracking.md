# Base Position “Nudge Mode” While Balancing

**Reference-Tracking State Feedback + Trapezoidal Reference + Debounced Pause/Resume (Reference Governor)**

This note documents the mathematics and real-time execution workflow used to command **arm/base position changes** (e.g., `T ±20°`) **while keeping a rotary inverted pendulum (Furuta/RIP) balanced upright**.

---

## 1) Goal

While the pendulum is stabilized upright, allow the base (arm) to move to a new commanded center position without losing balance:

* Maintain upright:
  [
  \alpha(t)\approx 0,\quad \dot{\alpha}(t)\approx 0
  ]
* Track a commanded base angle:
  [
  \theta(t)\to \theta_{\text{target}}
  ]
* Perform the move smoothly and safely via a moving reference (\theta_{\text{ref}}(t)) and supervisory logic.

---

## 2) Variables and Sign/Wrap Conventions

### 2.1 State variables (firmware signals)

* (\theta): base/arm angle (signed, degrees)
* (\alpha): pendulum angle about upright (signed, degrees)
* (\dot{\theta}): base angular rate estimate (deg/s)
* (\dot{\alpha}): pendulum angular rate estimate (deg/s)

### 2.2 Reference variables for base motion (“nudge mode”)

* (\theta_{\text{target}}): commanded base target (deg)
* (\theta_{\text{ref}}): internal base reference used by controller (deg)
* (\dot{\theta}_{\text{ref}}): reference velocity (deg/s)
* (\ddot{\theta}_{\text{ref}}): reference acceleration (deg/s²)

### 2.3 Wrap-safe angle difference

Angles are periodic; therefore, any subtraction ((a-b)) must use a wrap-safe operator so the result lies in ((-180^\circ,180^\circ]):

[
\mathrm{wrapDiff}(a,b)=a-b ;\text{wrapped into}; (-180^\circ,180^\circ]
]

This is used for:

* (\theta_e = \mathrm{wrapDiff}(\theta,\theta_{\text{ref}}))
* (d = \mathrm{wrapDiff}(\theta_{\text{target}},\theta_{\text{ref}}))

---

## 3) Core Control Concept: Regulator → Servo (Reference Tracking)

### 3.1 Original upright stabilizer (regulator form)

The upright controller was originally a regulator around (\theta=0,\alpha=0), of the form:

[
u = \ddot{\theta}_{\text{cmd}} = -\mathbf{K}\mathbf{x}
\quad\text{with}\quad
\mathbf{x} =
\begin{bmatrix}
\theta \ \alpha \ \dot{\theta} \ \dot{\alpha}
\end{bmatrix}
]

In implementation, the sign may be expressed as “positive magnitude gains + global sign convention” (e.g., `CTRL_SIGN`) rather than negative gains explicitly.

### 3.2 Servo form (tracking a moving base reference)

To command arm position while balancing, the controller is converted to track a base reference (\theta_{\text{ref}}(t)):

Define tracking error state:
[
\mathbf{e} = \mathbf{x}-\mathbf{x}*{\text{ref}},
\quad
\mathbf{x}*{\text{ref}}=
\begin{bmatrix}
\theta_{\text{ref}} \ 0 \ \dot{\theta}_{\text{ref}} \ 0
\end{bmatrix}
]

So the controller becomes:
[
\ddot{\theta}*{\text{cmd}} =
\ddot{\theta}*{\text{ref}}
-\mathbf{K}\mathbf{e}
]

Expanded:
[
\ddot{\theta}*{\text{cmd}}=
\ddot{\theta}*{\text{ref}}
--------------------------

\Big(
k_\theta(\theta-\theta_{\text{ref}})
+k_\alpha\alpha
+k_{\dot\theta}(\dot\theta-\dot\theta_{\text{ref}})
+k_{\dot\alpha}\dot\alpha
\Big)
]

**Interpretation:**

* The stabilizer is fundamentally the same (same closed-loop poles on the error dynamics).
* The equilibrium point for (\theta) is moved from (0) to (\theta_{\text{ref}}).
* Smoothly changing (\theta_{\text{ref}}) “nudges” the system to a new base location while the stabilizer maintains upright balance.

---

## 4) Implementation Units: Stepper Acceleration & Feedforward

The firmware operates in degrees but commands the stepper in steps/s².

Let:

* (S) = steps-per-degree (identified experimentally), e.g. (S = 4.444\ \text{steps/deg})

Reference feedforward in stepper units:
[
u_{\text{ff,steps}} = S\ \ddot{\theta}_{\text{ref}} \quad [\text{steps/s}^2]
]

The implemented controller computes (conceptually):
[
u_{\text{steps}} =
u_{\text{ff,steps}} +
K_\theta \theta_e +
K_\alpha \alpha +
K_{\dot\theta}\dot\theta_e +
K_{\dot\alpha}\dot\alpha
]
with:
[
\theta_e = \mathrm{wrapDiff}(\theta,\theta_{\text{ref}}),\quad
\dot\theta_e = \dot\theta-\dot\theta_{\text{ref}}
]

A global sign convention multiplier may be applied:
[
u_{\text{steps}} \leftarrow \mathrm{CTRL_SIGN}\cdot u_{\text{steps}}
]
and mapping to motor coordinates:
[
u_{\text{motor}} \leftarrow \mathrm{motorSign}\cdot u_{\text{steps}}
]

---

## 5) Reference Generation: Trapezoidal (Vel/Acc Limited) Profile

A step jump in (\theta_{\text{ref}}) would inject a large disturbance into the pendulum. Instead, (\theta_{\text{ref}}) is generated by a trapezoidal profile bounded by:

[
|\dot\theta_{\text{ref}}|\le v_{\max},\quad
|\ddot\theta_{\text{ref}}|\le a_{\max}
]

Discrete-time update at control tick (k) with (\Delta t):

1. Distance-to-go (wrap-safe):
   [
   d_k = \mathrm{wrapDiff}(\theta_{\text{target}},\theta_{\text{ref},k})
   ]

2. Stopping distance using current reference speed:
   [
   d_{\text{stop},k} = \frac{\dot\theta_{\text{ref},k}^2}{2a_{\max}}
   ]

3. Choose reference acceleration:

* Brake if close enough to need stopping:
  [
  |d_k|\le d_{\text{stop},k}
  \Rightarrow
  \ddot\theta_{\text{ref},k} = -\mathrm{sgn}(\dot\theta_{\text{ref},k}),a_{\max}
  ]
* Else accelerate toward target:
  [
  \ddot\theta_{\text{ref},k} = \mathrm{sgn}(d_k),a_{\max}
  ]

4. Integrate (with clamp):
   [
   \dot\theta_{\text{ref},k+1} =
   \mathrm{sat}\left(\dot\theta_{\text{ref},k}+\ddot\theta_{\text{ref},k}\Delta t,\ [-v_{\max},v_{\max}]\right)
   ]
   [
   \theta_{\text{ref},k+1}=
   \theta_{\text{ref},k}+\dot\theta_{\text{ref},k+1}\Delta t
   ]

5. Snap and overshoot guard:
   If (|d_k|<\varepsilon_\theta) and (|\dot\theta_{\text{ref},k}|<\varepsilon_{\dot\theta}), then:
   [
   \theta_{\text{ref}}=\theta_{\text{target}},\quad
   \dot\theta_{\text{ref}}=0,\quad
   \ddot\theta_{\text{ref}}=0
   ]
   If (\mathrm{sgn}(d_{k+1})\ne \mathrm{sgn}(d_k)), snap to target.

---

## 6) Supervisory Layer: Debounced Pause/Resume (Reference Governor)

Even with a smooth reference, disturbances can make continuing the move unsafe. A supervisory rule pauses the profile when the pendulum leaves a stability window.

### 6.1 Stability criterion

Define:
[
\mathrm{Stable}(k)=
\left(|\alpha_k|<\alpha_{\text{win}}\right)\land
\left(|\dot\alpha_k|<\dot\alpha_{\text{win}}\right)
]

Also apply an engage grace time:
[
t-t_{\text{engage}} > T_{\text{grace}}
]

### 6.2 Why debounce is essential

Without debounce, the condition can toggle rapidly (“chatter”), causing repeated pause/resume transitions. If pause entry resets (\theta_{\text{ref}}) frequently, it can unintentionally “forgive” base drift and allow the arm to walk into limits.

So we require consecutive ticks:

* Enter pause if unstable for (N_u) ticks
* Resume only if stable for (N_s) ticks

### 6.3 One-shot handoff on pause entry

When entering pause (after debounce), perform a one-shot handoff:
[
\theta_{\text{ref}} \leftarrow \theta,\quad
\dot\theta_{\text{ref}}\leftarrow 0,\quad
\ddot\theta_{\text{ref}}\leftarrow 0
]

**Effect:** this makes (\theta_e\approx 0) immediately, so the controller stops pushing the move objective and prioritizes restoring upright balance.

When stable again (debounced), resume trapezoid progression toward (\theta_{\text{target}}).

This behavior is equivalent to a simple **reference governor** that enforces safety constraints on ((\alpha,\dot\alpha)) by temporarily freezing the commanded reference.

---

## 7) Actuation: Acceleration Output → Velocity-Mode Stepper

The controller computes an acceleration-like command in stepper units:
[
u_{\text{motor}}(k) \equiv \ddot\theta_{\text{cmd,steps}}(k)
]

The stepper is commanded in **velocity mode**, so firmware integrates acceleration to a speed command:

[
v_{\text{cmd}}(k+1)=v_{\text{cmd}}(k)+\left(u_{\text{motor}}(k)-\lambda,v_{\text{cmd}}(k)\right)\Delta t
]

* (\lambda\ge 0) is a “velocity leak” (bias/drift killer), enabled only near upright and typically disabled during an active move.
* Speed is saturated: (|v_{\text{cmd}}|\le v_{\max,\text{steps}}).
* Direction is the sign of (v_{\text{cmd}}), magnitude sets step rate (Hz).

**Why velocity-mode matters:**
Velocity mode avoids “double integration / position chasing” artifacts that can happen when using stepper `moveTo()` while also integrating acceleration-like control internally.

---

## 8) Full Real-Time Workflow (Per Control Tick)

At each control tick (nominally 200 Hz):

1. **Sense**

* Read AS5600 pendulum absolute angle and base absolute angle via I2C mux.

2. **Convert to signed angles**

* Compute (\alpha) relative to pendulum calibration zero.
* Compute (\theta) relative to base calibration zero.
* Use wrap-safe differences.

3. **Glitch rejection**

* If a one-sample jump exceeds a threshold, ignore it.

4. **Derivative estimation**

* Compute (\dot\alpha,\dot\theta) via filtered differentiator:
  [
  \dot x[k]=b_0(x[k]-x[k-1]) - a_1\dot x[k-1]
  ]
  with clamping.

5. **Reference governor + trapezoid**

* Determine if a move is in progress.
* If moving and unstable (debounced): pause + one-shot handoff.
* If moving and stable: advance trapezoid to update (\theta_{\text{ref}},\dot\theta_{\text{ref}},\ddot\theta_{\text{ref}}).
* If not moving: set (\theta_{\text{ref}}=\theta_{\text{target}}), zero ref vel/acc.

6. **Compute tracking errors**
   [
   \theta_e=\mathrm{wrapDiff}(\theta,\theta_{\text{ref}}),\qquad
   \dot\theta_e=\dot\theta-\dot\theta_{\text{ref}}
   ]

7. **Compute control**
   [
   u_{\text{steps}} =
   S\ddot{\theta}*{\text{ref}} +
   K*\theta\theta_e +
   K_\alpha\alpha +
   K_{\dot\theta}\dot\theta_e +
   K_{\dot\alpha}\dot\alpha
   ]
   Apply sign convention and saturation.

8. **Integrate acceleration → speed command**
   [
   v_{\text{cmd}}(k+1)=v_{\text{cmd}}(k)+\left(u_{\text{motor}}(k)-\lambda v_{\text{cmd}}(k)\right)\Delta t
   ]
   Clamp and apply soft limits.

9. **Command stepper in velocity mode**

* `setSpeedInHz(|v_cmd|)` and `runForward/runBackward`.
* Optional deadband and stop-before-reverse logic to reduce chatter.

10. **Safety & logging**

* If (|\alpha|) or (|\theta|) exceeds limits for multiple ticks → disarm/fall state.
* Log telemetry at lower rate (e.g., 50 Hz).

---

## 9) Practical Notes (Reliability)

* **Smooth reference is mandatory:** step setpoints in (\theta_{\text{ref}}) inject large disturbances.
* **Debounced pause/resume is mandatory:** prevents chatter that can “wipe” reference state repeatedly.
* Gate slow bias mechanisms (auto-trim, leak) during motion to prevent fighting the profile.
* If loop timing jitter is significant, consider using a bounded effective (\Delta t) for the trapezoid step and accel→speed integration.

---

## 10) Implementation Mapping (Firmware-level summary)

* Base target command: `T <deg>` updates (\theta_{\text{target}})
* Reference generator: trapezoid update produces (\theta_{\text{ref}},\dot\theta_{\text{ref}},\ddot\theta_{\text{ref}})
* Controller uses:

  * `thetaErr = wrapDiff(thetaDeg, thetaRefDeg)`
  * `thetaDotErr = thetaDotFilt - thetaRefVelDegS`
  * feedforward `accFF = S * thetaRefAccDegS2`
* Output is integrated to a velocity command and sent via stepper velocity mode.

---
