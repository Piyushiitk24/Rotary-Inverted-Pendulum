#include <Arduino.h>
#include <Wire.h>
#include <SoftwareWire.h>
#include <AS5600.h>
#include <AccelStepper.h>

// Stepper Motor
#define STEP_PIN 5
#define DIR_PIN  6
#define EN_PIN   7
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// Pendulum Sensor on Hardware I2C
AS5600 as5600_pendulum(&Wire);

// Motor Sensor on Software I2C
#define MOTOR_SDA_PIN 22
#define MOTOR_SCL_PIN 24
#define AS5600_ADDRESS 0x36
#define AS5600_RAW_ANGLE_REG 0x0C
#define AS5600_STATUS_REG 0x0B
SoftwareWire motorWire(MOTOR_SDA_PIN, MOTOR_SCL_PIN);

// SYSTEM CONFIGURATION
#define MAX_POSITION_STEPS 3200
#define SOFT_LIMIT_STEPS 3000
#define HOMING_SPEED 500
#define NORMAL_SPEED 2000
#define NORMAL_ACCEL 4000
#define PENDULUM_UPRIGHT 0.0
#define PENDULUM_DEADBAND 5.0
#define PENDULUM_SWING_THRESHOLD 45.0
#define KP 15.0
#define KI 0.1
#define KD 5.0
#define CONTROL_LOOP_MS 10

enum SystemMode {
  MODE_STARTUP,
  MODE_HOMING,
  MODE_IDLE,
  MODE_MANUAL_TEST,
  MODE_BALANCE_CONTROL,
  MODE_EMERGENCY_STOP
};

SystemMode currentMode = MODE_STARTUP;

// Global variables
long motorZeroPosition = 0;
float pendulumZeroAngle = 0.0;
float integralError = 0.0;
float previousError = 0.0;
unsigned long lastControlTime = 0;
float pendulumAngle = 0.0;
float motorAngle = 0.0;
long motorPosition = 0;
unsigned long sensorTimestamp = 0;
bool sensorTestRunning = false;

// Sensor I2C helpers
uint16_t readAS5600Angle(SoftwareWire &wire) {
  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_RAW_ANGLE_REG);
  if (wire.endTransmission() != 0) return 0;
  wire.requestFrom(AS5600_ADDRESS, 2);
  if (wire.available() >= 2) {
    uint8_t high = wire.read();
    uint8_t low = wire.read();
    return (high << 8) | low;
  }
  return 0;
}

bool detectAS5600Magnet(SoftwareWire &wire) {
  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_STATUS_REG);
  if (wire.endTransmission() != 0) return false;
  wire.requestFrom(AS5600_ADDRESS, 1);
  if (wire.available()) {
    uint8_t status = wire.read();
    return (status & 0x20) != 0;
  }
  return false;
}

void updateSensorReadings() {
  uint16_t pendulum_raw = as5600_pendulum.readAngle();
  float pendulum_deg = (pendulum_raw * 360.0) / 4096.0;
  uint16_t motor_raw = readAS5600Angle(motorWire);
  float motor_deg = (motor_raw * 360.0) / 4096.0;
  pendulumAngle = pendulum_deg - pendulumZeroAngle;
  motorAngle = motor_deg;
  motorPosition = stepper.currentPosition();
  while (pendulumAngle > 180.0) pendulumAngle -= 360.0;
  while (pendulumAngle < -180.0) pendulumAngle += 360.0;
}

void performHoming() {
  Serial.println("\n=== HOMING PROCEDURE ===");
  Serial.println("MANUAL HOMING: Position the motor arm at your desired zero/center position.");
  Serial.println("Then position the pendulum STRAIGHT UP (vertical).");
  Serial.println("Press 'H' when ready to set this as the zero position...");
  currentMode = MODE_HOMING;
  while (true) {
    if (Serial.available() > 0) {
      char c = Serial.read();
      if (c == 'h' || c == 'H') {
        stepper.setCurrentPosition(0);
        motorZeroPosition = 0;
        uint16_t pendulum_raw = as5600_pendulum.readAngle();
        pendulumZeroAngle = (pendulum_raw * 360.0) / 4096.0;
        Serial.println("\n*** ZERO POSITION SET ***");
        Serial.print("Pendulum zero angle: ");
        Serial.print(pendulumZeroAngle, 2);
        Serial.println(" degrees");
        Serial.println("Motor position set to 0 steps");
        Serial.println("========================\n");
        currentMode = MODE_IDLE;
        break;
      }
    }
    delay(100);
  }
}

bool checkPositionLimits(long targetPosition) {
  if (targetPosition > MAX_POSITION_STEPS || targetPosition < -MAX_POSITION_STEPS) {
    Serial.println("ERROR: Target position exceeds hard limits!");
    return false;
  }
  if (targetPosition > SOFT_LIMIT_STEPS || targetPosition < -SOFT_LIMIT_STEPS) {
    Serial.println("WARNING: Approaching soft limits!");
  }
  return true;
}

void enforcePositionLimits() {
  long currentPos = stepper.currentPosition();
  if (currentPos > MAX_POSITION_STEPS) {
    stepper.setCurrentPosition(MAX_POSITION_STEPS);
    stepper.stop();
    Serial.println("HARD LIMIT REACHED: +MAX");
  } else if (currentPos < -MAX_POSITION_STEPS) {
    stepper.setCurrentPosition(-MAX_POSITION_STEPS);
    stepper.stop();
    Serial.println("HARD LIMIT REACHED: -MAX");
  }
}

float computePID(float error, float dt) {
  float P = KP * error;
  integralError += error * dt;
  if (integralError > 1000.0) integralError = 1000.0;
  if (integralError < -1000.0) integralError = -1000.0;
  float I = KI * integralError;
  float D = KD * (error - previousError) / dt;
  previousError = error;
  return P + I + D;
}

void resetPID() {
  integralError = 0.0;
  previousError = 0.0;
}

void runBalanceControl() {
  unsigned long currentTime = millis();
  if (currentTime - lastControlTime >= CONTROL_LOOP_MS) {
    float dt = (currentTime - lastControlTime) / 1000.0;
    lastControlTime = currentTime;
    updateSensorReadings();
    if (abs(pendulumAngle) > 90.0) {
      stepper.stop();
      integralError = 0.0;
      return;
    }
    float error = pendulumAngle - PENDULUM_UPRIGHT;
    float pidOutput = computePID(error, dt);
    long targetPosition = motorZeroPosition - (long)pidOutput;
    if (checkPositionLimits(targetPosition)) {
      stepper.moveTo(targetPosition);
    }
    stepper.run();
    enforcePositionLimits();
  } else {
    stepper.run();
  }
}

void printMenu() {
  Serial.println("\n=== ROTARY INVERTED PENDULUM CONTROL ===");
  Serial.print("Current Mode: ");
  switch(currentMode) {
    case MODE_STARTUP: Serial.println("STARTUP"); break;
    case MODE_HOMING: Serial.println("HOMING"); break;
    case MODE_IDLE: Serial.println("IDLE"); break;
    case MODE_MANUAL_TEST: Serial.println("MANUAL TEST"); break;
    case MODE_BALANCE_CONTROL: Serial.println("BALANCE CONTROL"); break;
    case MODE_EMERGENCY_STOP: Serial.println("EMERGENCY STOP"); break;
  }
  Serial.println("\n--- Main Menu ---");
  Serial.println("H - Home/Zero the system (set current position as zero)");
  Serial.println("1 - Motor Direction Test (Moves 90 deg & returns)");
  Serial.println("2 - Live Sensor Test (Streams both sensor angles)");
  Serial.println("3 - I2C Bus Scan (Check sensor connections)");
  Serial.println("4 - Start Balance Control (PID control to balance pendulum)");
  Serial.println("S - Stop/Return to Idle");
  Serial.println("E - Emergency Stop");
  Serial.print("Enter choice: ");
}

bool checkSerialForExit() {
  if (Serial.available() > 0) {
    char c = Serial.read();
    if (c == 'x' || c == 'X' || c == 's' || c == 'S') {
      sensorTestRunning = false;
      return true;
    }
    if (c == 'e' || c == 'E') {
      currentMode = MODE_EMERGENCY_STOP;
      stepper.stop();
      digitalWrite(EN_PIN, HIGH);
      Serial.println("\n!!! EMERGENCY STOP ACTIVATED !!!");
      return true;
    }
  }
  return false;
}

void runMotorTest() {
  Serial.println("\n--- Running Motor Test ---");
  Serial.println("Moving motor 'forward' (+800 steps)...");
  currentMode = MODE_MANUAL_TEST;
  long targetPos = 800;
  if (checkPositionLimits(targetPos)) {
    stepper.moveTo(targetPos);
    while (stepper.distanceToGo() != 0) {
      stepper.run();
      if (checkSerialForExit()) {
        stepper.stop();
        currentMode = MODE_IDLE;
        return;
      }
    }
  }
  Serial.println("...pausing for 2 seconds...");
  delay(2000);
  Serial.println("Returning to zero...");
  stepper.moveTo(0);
  while (stepper.distanceToGo() != 0) {
    stepper.run();
    if (checkSerialForExit()) {
      stepper.stop();
      currentMode = MODE_IDLE;
      return;
    }
  }
  Serial.println("--- Motor Test Complete ---");
  currentMode = MODE_IDLE;
}

void startSensorTest() {
  Serial.println("\n--- Running Live Sensor Test ---");
  Serial.println("Streaming live data... Type 'S' to stop.");
  Serial.println("-------------------------------------------------");
  Serial.println("Pendulum (deg) \t Motor (deg) \t Motor (steps)");
  Serial.println("-------------------------------------------------");
  while(Serial.available()) Serial.read();
  sensorTimestamp = millis();
  sensorTestRunning = true;
  currentMode = MODE_MANUAL_TEST;
}

void updateSensorTest() {
  if (checkSerialForExit()) {
    Serial.println("--- Sensor Test Complete ---");
    currentMode = MODE_IDLE;
    printMenu();
    return;
  }
  if (millis() - sensorTimestamp >= 100) {
    sensorTimestamp = millis();
    updateSensorReadings();
    Serial.print(pendulumAngle, 2);
    Serial.print(" \t\t");
    Serial.print(motorAngle, 2);
    Serial.print(" \t\t");
    Serial.println(motorPosition);
  }
}

void runI2CScan() {
  Serial.println("\n--- I2C Bus Scanner ---");
  Serial.println("\nScanning Hardware I2C (pins 20/21):");
  byte hw_count = 0;
  for (byte addr = 1; addr < 127; addr++) {
    Wire.beginTransmission(addr);
    if (Wire.endTransmission() == 0) {
      Serial.print("  Device at 0x");
      if (addr < 16) Serial.print("0");
      Serial.print(addr, HEX);
      if (addr == 0x36) Serial.print(" (AS5600)");
      Serial.println();
      hw_count++;
    }
  }
  if (hw_count == 0) Serial.println("  No devices found!");
  Serial.println("\nScanning Software I2C (pins 22/24):");
  byte sw_count = 0;
  for (byte addr = 1; addr < 127; addr++) {
    motorWire.beginTransmission(addr);
    if (motorWire.endTransmission() == 0) {
      Serial.print("  Device at 0x");
      if (addr < 16) Serial.print("0");
      Serial.print(addr, HEX);
      if (addr == 0x36) Serial.print(" (AS5600)");
      Serial.println();
      sw_count++;
    }
  }
  if (sw_count == 0) Serial.println("  No devices found!");
  Serial.println("\n--- Scan Complete ---");
}

void startBalanceControl() {
  Serial.println("\n=== STARTING BALANCE CONTROL ===");
  Serial.println("System will now attempt to balance the pendulum.");
  Serial.println("Make sure pendulum is close to upright position!");
  Serial.println("Press 'S' to stop, 'E' for emergency stop.");
  Serial.println("================================\n");
  resetPID();
  lastControlTime = millis();
  currentMode = MODE_BALANCE_CONTROL;
  delay(1000);
}

void setup() {
  Serial.begin(115200);
  delay(2000);
  Serial.println("\n\n===========================================");
  Serial.println("  ROTARY INVERTED PENDULUM CONTROL SYSTEM");
  Serial.println("===========================================\n");
  pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, LOW);
  stepper.setMaxSpeed(NORMAL_SPEED);
  stepper.setAcceleration(NORMAL_ACCEL);
  stepper.setCurrentPosition(0);
  Serial.println("[OK] Motor Driver Enabled");
  Wire.begin();
  delay(100);
  as5600_pendulum.begin();
  if (!as5600_pendulum.detectMagnet()) {
    Serial.println("[ERROR] Pendulum Sensor not detected!");
  } else {
    Serial.println("[OK] Pendulum Sensor Connected");
  }
  motorWire.begin();
  motorWire.setClock(100000);
  delay(100);
  if (!detectAS5600Magnet(motorWire)) {
    Serial.println("[ERROR] Motor Sensor not detected!");
  } else {
    Serial.println("[OK] Motor Sensor Connected");
  }
  Serial.println("\n===========================================\n");
  currentMode = MODE_STARTUP;
  printMenu();
}

void loop() {
  switch (currentMode) {
    case MODE_STARTUP:
    case MODE_IDLE:
      if (Serial.available() > 0) {
        char c = Serial.read();
        if (c == 'h' || c == 'H') {
          performHoming();
          printMenu();
        } else if (c == '1') {
          runMotorTest();
          printMenu();
        } else if (c == '2') {
          startSensorTest();
        } else if (c == '3') {
          runI2CScan();
          printMenu();
        } else if (c == '4') {
          if (currentMode == MODE_STARTUP) {
            Serial.println("Please home the system first (press 'H')");
            printMenu();
          } else {
            startBalanceControl();
          }
        } else if (c == 's' || c == 'S') {
          currentMode = MODE_IDLE;
          stepper.stop();
          Serial.println("Stopped. Returning to idle.");
          printMenu();
        } else if (c == 'e' || c == 'E') {
          currentMode = MODE_EMERGENCY_STOP;
          stepper.stop();
          digitalWrite(EN_PIN, HIGH);
          Serial.println("\n!!! EMERGENCY STOP !!!");
          Serial.println("Power cycle or press 'H' to re-enable.");
        } else if (c != '\n' && c != '\r') {
          Serial.println("Invalid choice.");
          printMenu();
        }
      }
      break;
    case MODE_MANUAL_TEST:
      if (sensorTestRunning) {
        updateSensorTest();
      }
      break;
    case MODE_BALANCE_CONTROL:
      if (checkSerialForExit()) {
        currentMode = MODE_IDLE;
        stepper.stop();
        Serial.println("\nBalance control stopped.");
        printMenu();
      } else {
        runBalanceControl();
      }
      break;
    case MODE_EMERGENCY_STOP:
      if (Serial.available() > 0) {
        char c = Serial.read();
        if (c == 'h' || c == 'H') {
          digitalWrite(EN_PIN, LOW);
          performHoming();
          printMenu();
        }
      }
      break;
    default:
      currentMode = MODE_IDLE;
      break;
  }
}
