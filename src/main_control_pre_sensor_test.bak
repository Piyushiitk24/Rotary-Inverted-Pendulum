#include <Arduino.h>
#include <Wire.h>
// #include <SoftwareWire.h> // No longer needed
#include <AS5600.h>
#include <AccelStepper.h>
#include <math.h>

// ============================================================
//  ROTARY INVERTED PENDULUM - STEPPER-BASED CONTROL
// ============================================================
//
// V4.8 - 24V POWER ENABLED
// - 24V Power Supply
// - TMC2209 Vref = 2.11V (for 1.5A RMS)
// - Pendulum Sensor: AS5600 (Hardware I2C)
// - Motor Position: Stepper Count (Virtual Encoder)
//
// ============================================================

// Stepper Motor Pins
#define STEP_PIN 5
#define DIR_PIN  6
#define EN_PIN   7
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// Pendulum Sensor on Hardware I2C (pins 20/21)
AS5600 as5600_pendulum(&Wire);

// Motor configuration
// --- 24V HIGH PERFORMANCE VALUES ---
// With 24V and 1.5A, the motor can now handle high speeds.
#define MOTOR_SPEED 12000     // (Was 4000)
#define MOTOR_ACCEL 30000     // (Was 8000)
// ---
#define CALIBRATION_SPEED 1000
#define JOG_SPEED 2000

// System states
enum SystemState {
  STATE_STARTUP,
  STATE_ZEROING,
  STATE_CALIBRATION,
  STATE_IDLE,
  STATE_SWING_UP,
  STATE_BALANCE,
  STATE_EMERGENCY_STOP,
  STATE_MONITORING,   // New state for non-blocking monitor
  STATE_MOVING        // New state for non-blocking moves
};

SystemState currentState = STATE_STARTUP;

// Calibration data
float pendulumZeroAngle = 0.0;
long stepsAtZero = 0;
long stepsAtLeftLimit = 0;
long stepsAtRightLimit = 0;
bool systemCalibrated = false;
bool leftLimitSet = false;   // Track if left limit was set
bool rightLimitSet = false;  // Track if right limit was set

// Current sensor readings
float pendulumAngle = 0.0;  // relative to zero (upright)
uint16_t pendulumRaw = 0;

// Control parameters (static defaults tuned for lightweight PLA build)
float Kp_balance = 5.0;
float Kd_balance = 1.0;
float Ki_balance = 0.1;
float Kp_motor = 0.05;

float balanceThreshold = 25.0; // Switch to balance mode (degrees)

// Constants
const float DEG2RAD = PI / 180.0;

// Control state
float previousPendulumAngle = 0.0;
float integralError = 0.0;
unsigned long lastControlTime = 0;
#define CONTROL_LOOP_MS 10 // 10ms = 100Hz control loop

// Live tuning removed – commands are single-key menu entries only

// Forward declarations
void checkSerialInput();
void parseSerialCommand(String cmd);
void printMenu();

// ============================================================
//  SENSOR I2C FUNCTIONS
// ============================================================

// Helper for median filter
void insertionSort(uint16_t arr[], int n) {
  int i, key, j;
  for (i = 1; i < n; i++) {
    key = arr[i];
    j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
}

// Read sensor with a 3-sample median filter for EMI rejection
uint16_t readAngleMedian(AS5600 &sensor) {
  uint16_t readings[3];
  readings[0] = sensor.readAngle();
  delayMicroseconds(100);
  readings[1] = sensor.readAngle();
  delayMicroseconds(100);
  readings[2] = sensor.readAngle();
  insertionSort(readings, 3);
  return readings[1]; // Return median value
}

float normalizeAngle(float angle) {
  while (angle > 180.0) angle -= 360.0;
  while (angle < -180.0) angle += 360.0;
  return angle;
}

// Handle angle wraparound for derivative calculation
float normalizeAngleDelta(float delta) {
  while (delta > 180.0f) delta -= 360.0f;
  while (delta < -180.0f) delta += 360.0f;
  return delta;
}

void updateSensors() {
  // Read pendulum sensor (Hardware I2C)
  pendulumRaw = readAngleMedian(as5600_pendulum);
  float pendulum_deg = (pendulumRaw * 360.0) / 4096.0;
  pendulumAngle = normalizeAngle(pendulum_deg - pendulumZeroAngle);
}

// ============================================================
//  STARTUP DIAGNOSTICS
// ============================================================

bool checkSystemHealth() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║      SYSTEM DIAGNOSTICS                    ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  
  bool allGood = true;
  
  // Check motor driver
  Serial.print(F("Motor Driver... "));
  digitalWrite(EN_PIN, LOW);
  delay(100);
  Serial.println(F("✓ Enabled"));
  
  // Check pendulum sensor
  Serial.print(F("Pendulum Sensor (Hardware I2C 0x36)... "));
  if (!as5600_pendulum.detectMagnet()) {
    Serial.println(F("✗ FAILED - No magnet detected!"));
    allGood = false;
  } else {
    uint16_t raw = readAngleMedian(as5600_pendulum);
    Serial.print(F("✓ OK (raw: "));
    Serial.print(raw);
    Serial.println(F(")"));
  }
  
  // Test motor movement
  Serial.print(F("Motor Movement Test... "));
  long startPos = stepper.currentPosition();
  stepper.setMaxSpeed(1000); // Use a known speed
  stepper.moveTo(startPos + 200); // Move 200 steps
  while(stepper.distanceToGo() != 0) {
    stepper.run();
  }
  stepper.moveTo(startPos); // Move back
  while(stepper.distanceToGo() != 0) {
    stepper.run();
  }
  stepper.setCurrentPosition(startPos); // Reset
  Serial.println(F("✓ Motor responds"));
  
  // USER FIX 5.2: Disable motor after test
  digitalWrite(EN_PIN, HIGH);
  
  Serial.println();
  if (allGood) {
    Serial.println(F("✅ ALL SYSTEMS OPERATIONAL"));
  } else {
    Serial.println(F("❌ SYSTEM CHECK FAILED - Fix errors before proceeding"));
  }
  Serial.println(F("════════════════════════════════════════════\n"));
  
  return allGood;
}

// ============================================================
//  MENU ACTIONS (NOW NON-BLOCKING)
// ============================================================

void performZeroing() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║      ZERO POSITION SETUP                   ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  Serial.println(F("1. Position the motor arm at CENTER"));
  Serial.println(F("2. Hold the pendulum STRAIGHT UP (vertical)"));
  Serial.println(F("3. Press 'Z' when ready to set zero position\n"));
  
  currentState = STATE_ZEROING;
  // Don't block - return and let main loop handle input
}

void liveMonitorSensors() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║      LIVE SENSOR MONITORING                ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  Serial.println(F("Streaming pendulum sensor. Press 'X' to stop.\n"));
  Serial.println(F("────────────────────────────────────────────────"));
  Serial.println(F("Pendulum(°) | Pendulum Raw | Steps"));
  Serial.println(F("────────────────────────────────────────────────"));
  
  currentState = STATE_MONITORING; // Set new state
  // REMOVED BLOCKING while(true) LOOP
  // The main loop() will now handle the printing
}

void calibrateLimits() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║      LIMIT CALIBRATION                     ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  Serial.println(F("Use 'A'/'D' keys to jog, 'L'/'R' to set limits"));
  Serial.println(F("Press 'Q' to quit calibration\n"));
  
  currentState = STATE_CALIBRATION;
  leftLimitSet = false;   // Reset flags
  rightLimitSet = false;
  digitalWrite(EN_PIN, LOW); // Enable motor for jogging
  stepper.setMaxSpeed(JOG_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  // REMOVED BLOCKING while(true) LOOP
  // The main loop() will now handle stepper.run() and checkSerialInput()
}

void returnToCenter() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║      RETURNING TO CENTER                   ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  
  digitalWrite(EN_PIN, LOW); // Enable motor
  stepper.setMaxSpeed(MOTOR_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  stepper.moveTo(stepsAtZero);

  currentState = STATE_MOVING; // Set state to MOVING
  // REMOVED BLOCKING while(true) LOOP
  // The main loop() will run the motor
}

// ============================================================
//  CONTROL SYSTEM - BANG-BANG SWING-UP
// ============================================================

void runSwingUp() {
  updateSensors();
  
  // Estimate velocity (rad/s)
  float angleDelta = normalizeAngleDelta(pendulumAngle - previousPendulumAngle);
  float alpha_dot = (angleDelta * DEG2RAD) / (CONTROL_LOOP_MS / 1000.0);
  
  previousPendulumAngle = pendulumAngle;
  
  // Check if ready to switch to BALANCE (near upright AND slow)
  if (abs(pendulumAngle) < balanceThreshold && abs(alpha_dot) < 2.0) { // 2.0 rad/s = ~115 deg/s
    Serial.println(F("\n✓ Pendulum near upright & slow - Switching to BALANCE mode"));
    currentState = STATE_BALANCE;
    integralError = 0.0;
    lastControlTime = millis();
    // previousPendulumAngle is already set
    return;
  }
  
  // True Bang-Bang Logic
  long targetSteps;
  float alpha_rad = pendulumAngle * DEG2RAD;
  if (alpha_dot * cos(alpha_rad) > 0) {
    // Moving away from upright → push to the RIGHT limit
    targetSteps = stepsAtRightLimit;
  } else {
    // Moving toward upright → push to the LEFT limit
    targetSteps = stepsAtLeftLimit;
  }
  
  stepper.moveTo(targetSteps);
  // stepper.run() is called in main loop
}

// ============================================================
//  CONTROL SYSTEM - PID BALANCE
// ============================================================

void runBalance() {
  updateSensors();
  
  // Use fixed dt for consistent control
  const float dt = CONTROL_LOOP_MS / 1000.0;  // 0.01s
  
  // Check if pendulum fell
  if (abs(pendulumAngle) > 60.0) {
    Serial.println(F("\n⚠ Pendulum fell - Returning to IDLE"));
    stepper.stop();
    currentState = STATE_IDLE;
    digitalWrite(EN_PIN, HIGH); // Disable motor
    return;
  }
  
  // PID control on pendulum angle
  float error = pendulumAngle; // Want it at 0°
  integralError += error * dt;
  
  // Anti-windup
  if (integralError > 100.0) integralError = 100.0;
  if (integralError < -100.0) integralError = -100.0;
  
  float angleDelta = normalizeAngleDelta(pendulumAngle - previousPendulumAngle);
  float derivative = angleDelta / dt;
  
  previousPendulumAngle = pendulumAngle;
  
  float pidOutput = Kp_balance * error + Ki_balance * integralError + Kd_balance * derivative;
  
  // Also include motor position feedback (keep centered)
  float motorStepError = (float)stepper.currentPosition() - (float)stepsAtZero;
  float motorCorrection = -Kp_motor * motorStepError;
  
  float totalControl = pidOutput + motorCorrection;
  
  // CRITICAL LOGIC FIX (v4.3)
  long targetSteps = stepsAtZero + (long)(totalControl);
  
  // Enforce limits
  if (targetSteps < stepsAtLeftLimit) targetSteps = stepsAtLeftLimit;
  if (targetSteps > stepsAtRightLimit) targetSteps = stepsAtRightLimit;
  
  stepper.moveTo(targetSteps);
  // stepper.run() is called in main loop
}

// ============================================================
//  MAIN MENU & CONTROL TICK
// ============================================================

void printTuningGains() {
  Serial.println(F("\n--- Current Gains (24V Enabled) ---"));
  Serial.print(F("Kp = ")); Serial.println(Kp_balance, 4);
  Serial.print(F("Kd = ")); Serial.println(Kd_balance, 4);
  Serial.print(F("Ki = ")); Serial.println(Ki_balance, 4);
  Serial.print(F("Km = ")); Serial.println(Kp_motor, 4);
  Serial.println(F("------------------------------------"));
}

void printMenu() {
  Serial.println(F("\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║  ROTARY INVERTED PENDULUM CONTROL (v4.8)  ║"));
  Serial.println(F("╚════════════════════════════════════════════╝"));
  Serial.print(F("\nState: "));
  switch(currentState) {
    case STATE_STARTUP: Serial.println(F("STARTUP")); break;
    case STATE_ZEROING: Serial.println(F("ZEROING")); break;
    case STATE_CALIBRATION: Serial.println(F("CALIBRATION")); break;
    case STATE_IDLE: Serial.println(F("IDLE")); break;
    case STATE_SWING_UP: Serial.println(F("SWING-UP ACTIVE")); break;
    case STATE_BALANCE: Serial.println(F("BALANCING")); break;
    case STATE_EMERGENCY_STOP: Serial.println(F("EMERGENCY STOP")); break;
    case STATE_MONITORING: Serial.println(F("MONITORING")); break;
    case STATE_MOVING: Serial.println(F("MOVING")); break;
    default: Serial.println(F("UNKNOWN"));
  }
  Serial.print(F("Calibrated: "));
  Serial.println(systemCalibrated ? F("YES") : F("NO"));
  Serial.println(F("\n--- SETUP SEQUENCE ---"));
  Serial.println(F("1 - System Diagnostics"));
  Serial.println(F("2 - Set Zero Position"));
  Serial.println(F("3 - Live Sensor Monitoring"));
  Serial.println(F("4 - Calibrate Left/Right Limits"));
  Serial.println(F("5 - Return to Center"));
  Serial.println(F("\n--- CONTROL ---"));
  Serial.println(F("S - Start Swing-Up & Balance"));
  Serial.println(F("B - Balance Test (manual start from upright)"));
  Serial.println(F("X - Stop Control"));
  Serial.println(F("E - Emergency Stop"));
  Serial.println(F("T - Show Current Tuning Gains"));
  Serial.println(F("════════════════════════════════════════════"));
  Serial.print(F("Choice: "));
}

// New function to run control logic at a fixed rate
void controlTick() {
  // This function is called every 10ms by the timer in loop()
  if (currentState == STATE_SWING_UP) {
    runSwingUp();
  } else if (currentState == STATE_BALANCE) {
    runBalance();
  }
}

// ============================================================
//  NEW: NON-BLOCKING COMMAND PARSER
// ============================================================

void parseSerialCommand(String cmd) {
  if (cmd.length() == 0) return;
  char commandType = cmd.charAt(0);

  // These commands work in ANY state (Stop/Status)
  switch (commandType) {
    case 'T': case 't':
      printTuningGains();
      return;
    case 'X': case 'x':
      stepper.stop();
      digitalWrite(EN_PIN, HIGH);
      if (currentState == STATE_MONITORING) {
        Serial.println(F("\n✓ Monitoring stopped"));
      } else if (currentState == STATE_SWING_UP || currentState == STATE_BALANCE) {
        Serial.println(F("\n✓ Control stopped"));
      } else if (currentState == STATE_CALIBRATION) {
         Serial.println(F("\n✓ Calibration stopped"));
      }
      currentState = STATE_IDLE;
      printMenu();
      return;
    case 'E': case 'e':
      stepper.stop();
      digitalWrite(EN_PIN, HIGH);
      currentState = STATE_EMERGENCY_STOP;
      Serial.println(F("\n!!! EMERGENCY STOP !!!"));
      Serial.println(F("Power cycle or reset to continue.\n"));
      return;
  }

  // --- Menu commands below only work if NOT in a control state ---
  if (currentState == STATE_SWING_UP || currentState == STATE_BALANCE || currentState == STATE_MOVING) {
    Serial.println(F("Must press 'X' to stop control before giving menu commands."));
    return;
  }
  
  // Special handling for calibration mode commands
  if (currentState == STATE_CALIBRATION) {
    switch (commandType) {
      case 'a': case 'A':
        stepper.move(-50); // Set target, main loop will run it
        Serial.println(F("← Jogging Left 50 steps..."));
        return;
      case 'd': case 'D':
        stepper.move(50); // Set target, main loop will run it
        Serial.println(F("→ Jogging Right 50 steps..."));
        return;
      case 'l': case 'L':
        stepsAtLeftLimit = stepper.currentPosition();
        leftLimitSet = true;
        Serial.print(F("\n✓ LEFT LIMIT SET: ")); Serial.print(stepsAtLeftLimit); Serial.println(F(" steps\n"));
        return;
      case 'r': case 'R':
        stepsAtRightLimit = stepper.currentPosition();
        rightLimitSet = true;
        Serial.print(F("\n✓ RIGHT LIMIT SET: ")); Serial.print(stepsAtRightLimit); Serial.println(F(" steps\n"));
        return;
      case 'q': case 'Q':
        if (leftLimitSet && rightLimitSet) {
          if (stepsAtLeftLimit > stepsAtRightLimit) {
            Serial.println(F("   (i) Note: Limits were entered backward and have been swapped."));
            long tmp = stepsAtLeftLimit;
            stepsAtLeftLimit = stepsAtRightLimit;
            stepsAtRightLimit = tmp;
          }
          systemCalibrated = true;
          digitalWrite(EN_PIN, HIGH); // Disable motor after calibration
          currentState = STATE_IDLE;
          Serial.println(F("\n✅ CALIBRATION COMPLETE!"));
          Serial.print(F("   Range: ")); Serial.print(stepsAtRightLimit - stepsAtLeftLimit); Serial.println(F(" steps")); 
          Serial.println(F("════════════════════════════════════════════\n"));
          printMenu();
        } else {
          Serial.println(F("\n⚠ Must set both LEFT and RIGHT limits before quitting!\n"));
        }
        return;
    }
  }

  // Special handling for zeroing mode
  if (currentState == STATE_ZEROING) {
    if (commandType == 'z' || commandType == 'Z') {
      stepper.setCurrentPosition(0);
      stepsAtZero = 0;
      uint16_t pendulum_raw = readAngleMedian(as5600_pendulum);
      pendulumZeroAngle = (pendulum_raw * 360.0) / 4096.0;
      Serial.println(F("\n✅ ZERO POSITION SET!"));
      Serial.print(F("   Pendulum zero: ")); Serial.print(pendulumZeroAngle, 2); Serial.println(F("°"));
      Serial.print(F("   Motor zero: 0 steps")); Serial.println();
      Serial.println(F("════════════════════════════════════════════\n"));
      updateSensors();
      previousPendulumAngle = pendulumAngle;
      currentState = STATE_IDLE;
      printMenu();
    }
    return;
  }

  // --- Standard Menu Commands (must be in IDLE or STARTUP) ---
  if (currentState == STATE_IDLE || currentState == STATE_STARTUP) {
    switch (commandType) {
      case '1':
        checkSystemHealth();
        printMenu();
        break;
      case '2':
        performZeroing();
        // Menu will be shown after 'Z' is pressed
        break;
      case '3':
        liveMonitorSensors();
        // printMenu() is NOT called, 'X' will call it
        break;
      case '4':
        calibrateLimits();
        // printMenu() is called by parseSerialCommand on 'Q'
        break;
      case '5':
        if (!systemCalibrated) {
          Serial.println(F("\nMust calibrate limits first (option 4).\n"));
          printMenu();
        } else {
          returnToCenter();
          // printMenu() will be called from main loop when move finishes
        }
        break;
      case 's': case 'S':
        if (!systemCalibrated) {
          Serial.println(F("\n⚠ Cannot start - System not calibrated!"));
          Serial.println(F("Complete setup sequence (options 1-5) first.\n"));
          printMenu();
        } else {
          Serial.println(F("\n╔════════════════════════════════════════════╗"));
          Serial.println(F("║  STARTING SWING-UP CONTROL                 ║"));
          Serial.println(F("╚════════════════════════════════════════════╝\n"));
          Serial.println(F("Pull pendulum down, then release..."));
          Serial.println(F("Press 'X' to stop.\n"));
          digitalWrite(EN_PIN, LOW);
          updateSensors();
          previousPendulumAngle = pendulumAngle;
          delay(1000); // Give user time to release
          currentState = STATE_SWING_UP;
          lastControlTime = millis();
        }
        break;
      case 'b': case 'B':
        if (!systemCalibrated) {
          Serial.println(F("\n⚠ Cannot start - System not calibrated!"));
          Serial.println(F("Complete setup sequence (options 1-5) first.\n"));
          printMenu();
        } else {
          Serial.println(F("\n╔════════════════════════════════════════════╗"));
          Serial.println(F("║  BALANCE TEST MODE                         ║"));
          Serial.println(F("╚════════════════════════════════════════════╝\n"));
          Serial.println(F("Hold pendulum near upright, then release..."));
          Serial.println(F("Press 'X' to stop.\n"));
          digitalWrite(EN_PIN, LOW);
          updateSensors();
          previousPendulumAngle = pendulumAngle;
          integralError = 0.0;
          delay(1000); // Give user time to release
          currentState = STATE_BALANCE;
          lastControlTime = millis();
        }
        break;
      
      default:
        Serial.println(F("\nInvalid choice."));
        printMenu();
        break;
    }
  }
}

// New non-blocking function to check for serial commands
void checkSerialInput() {
  while (Serial.available() > 0) {
    char inChar = (char)Serial.read();
    if (inChar == '\n' || inChar == '\r') {
      continue; // Ignore line endings entirely
    }

    if (inChar >= ' ') {
      Serial.print(inChar);
      Serial.println();
      parseSerialCommand(String(inChar));
    }
  }
}

// ============================================================
//  SETUP
// ============================================================

void setup() {
  // Initialize pins
  pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, HIGH); // Disabled initially
  pinMode(STEP_PIN, OUTPUT);
  digitalWrite(STEP_PIN, LOW);
  pinMode(DIR_PIN, OUTPUT);
  digitalWrite(DIR_PIN, LOW);
  
  // Initialize serial
  Serial.begin(115200);
  delay(2000);
  
  Serial.println(F("\n\n╔════════════════════════════════════════════╗"));
  Serial.println(F("║  ROTARY INVERTED PENDULUM - FULL SYSTEM   ║"));
  Serial.println(F("║  Step-Based Calibration & Control (v4.8)  ║"));
  Serial.println(F("╚════════════════════════════════════════════╝\n"));
  
  // Configure stepper
  stepper.setMaxSpeed(MOTOR_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  stepper.setCurrentPosition(0);
  
  // Initialize Hardware I2C (pendulum sensor)
  Wire.begin();
  Wire.setClock(100000); // 100kHz for noise robustness
  delay(100);
  as5600_pendulum.begin();
  
  Serial.println(F("System initialized. Run diagnostics (option 1) first.\n"));
  Serial.flush(); // Ensure output is sent
  
  currentState = STATE_STARTUP;
  printMenu();
  Serial.flush(); // Ensure menu is sent
}

// ============================================================
//  MAIN LOOP (NEW ARCHITECTURE)
// ============================================================

void loop() {
  // Main loop must run as fast as possible
  
  // 1. Run the non-blocking serial command checker
  checkSerialInput();

  // 2. Handle control logic at a fixed rate (100Hz)
  unsigned long now = millis();
  if (now - lastControlTime >= CONTROL_LOOP_MS) {
    lastControlTime = now;
    if (currentState == STATE_SWING_UP || currentState == STATE_BALANCE) {
      controlTick();
    }
  }

  // 3. Handle sensor monitoring display (if active)
  static unsigned long lastMonitorPrint = 0;
  if (currentState == STATE_MONITORING && (now - lastMonitorPrint >= 200)) {
    lastMonitorPrint = now;
    updateSensors();
    Serial.print(F("  "));
    Serial.print(pendulumAngle, 2);
    Serial.print(F("°   \t"));
    Serial.print(pendulumRaw);
    Serial.print(F("  \t"));
    Serial.println(stepper.currentPosition());
  }

  // 4. Run the stepper motor
  // This must be run for ALL states that can move the motor
  if (currentState == STATE_SWING_UP || 
      currentState == STATE_BALANCE || 
      currentState == STATE_CALIBRATION || 
      currentState == STATE_MOVING) {
    stepper.run();
  }

  // 5. Check for completion of non-blocking moves
  if (currentState == STATE_MOVING && stepper.distanceToGo() == 0) {
    // The "returnToCenter" move has finished
    currentState = STATE_IDLE;
    digitalWrite(EN_PIN, HIGH); // Disable motor
    Serial.print(F("✓ At center | Steps: "));
    Serial.println(stepper.currentPosition());
    Serial.println(F("════════════════════════════════════════════\n"));
    printMenu();
  }
  
  // The old blocking serial menu is GONE.
  // All commands are handled by checkSerialInput() -> parseSerialCommand()
}
