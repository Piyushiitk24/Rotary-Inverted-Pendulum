#include <Arduino.h>
#include <Wire.h>
#include <SoftwareWire.h>
#include <AS5600.h>
#include <AccelStepper.h>
#include <math.h>

// ============================================================
//  ROTARY INVERTED PENDULUM - SENSOR-BASED CONTROL
// ============================================================
//
// WORKFLOW:
// 1. Startup diagnostics (both sensors + motor)
// 2. Set zero position (center arm, pendulum up)
// 3. Test sensors continuously
// 4. Calibrate left/right limits (sensor-based)
// 5. Return to center
// 6. Energy-based swing-up with constraints
// 7. LQR balance control
//
// ============================================================

// Stepper Motor Pins
#define STEP_PIN 5
#define DIR_PIN  6
#define EN_PIN   7
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// Pendulum Sensor on Hardware I2C (pins 20/21)
AS5600 as5600_pendulum(&Wire);

// Motor Sensor on Software I2C (pins 22/24)
#define MOTOR_SDA_PIN 22
#define MOTOR_SCL_PIN 24
#define AS5600_ADDRESS 0x36
#define AS5600_RAW_ANGLE_REG 0x0C
#define AS5600_STATUS_REG 0x0B
SoftwareWire motorWire(MOTOR_SDA_PIN, MOTOR_SCL_PIN);

// Motor configuration
#define MOTOR_SPEED 12000     // Increased for faster swing-up
#define MOTOR_ACCEL 30000     // Increased for quicker response
#define CALIBRATION_SPEED 1000
#define JOG_SPEED 2000

// System states
enum SystemState {
  STATE_STARTUP,
  STATE_ZEROING,
  STATE_CALIBRATION,
  STATE_IDLE,
  STATE_SWING_UP,
  STATE_BALANCE,
  STATE_EMERGENCY_STOP
};

SystemState currentState = STATE_STARTUP;

// Calibration data
float pendulumZeroAngle = 0.0;
float motorZeroAngle = 0.0;
float motorLeftLimit = 0.0;   // degrees, sensor-based
float motorRightLimit = 0.0;  // degrees, sensor-based
long stepsAtZero = 0;
long stepsAtLeftLimit = 0;
long stepsAtRightLimit = 0;
bool systemCalibrated = false;

// Current sensor readings
float pendulumAngle = 0.0;  // relative to zero (upright)
float motorAngle = 0.0;     // relative to zero (center)
uint16_t pendulumRaw = 0;
uint16_t motorRaw = 0;

// Control parameters (will be tuned)
float Kp_swing = 150.0;      // Swing-up bang-bang gain (steps)
float Kp_balance = 1.2;      // Balance proportional gain
float Kd_balance = 0.015;      // Balance derivative gain
float Ki_balance = 24.0;      // Balance integral gain
float balanceThreshold = 25.0; // Switch to balance mode (degrees)
float balanceScale = 2.0;    // Steps scaling for balance control

// Constants
const float DEG2RAD = PI / 180.0;

// Control state
float previousPendulumAngle = 0.0;
float integralError = 0.0;
unsigned long lastControlTime = 0;
#define CONTROL_LOOP_MS 10 // 10ms = 100Hz control loop

// ============================================================
//  SENSOR I2C FUNCTIONS
// ============================================================

// Helper for median filter
void insertionSort(uint16_t arr[], int n) {
  int i, key, j;
  for (i = 1; i < n; i++) {
    key = arr[i];
    j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
}

// BUGFIX #3: Read sensor with a 3-sample median filter for EMI rejection
uint16_t readAngleMedian(AS5600 &sensor) {
  uint16_t readings[3];
  readings[0] = sensor.readAngle();
  delayMicroseconds(100);
  readings[1] = sensor.readAngle();
  delayMicroseconds(100);
  readings[2] = sensor.readAngle();
  insertionSort(readings, 3);
  return readings[1]; // Return median value
}

// BUGFIX #3: Median filter for SoftwareWire
uint16_t readAngleMedian(SoftwareWire &wire) {
  uint16_t readings[3];
  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_RAW_ANGLE_REG);
  wire.endTransmission();
  wire.requestFrom(AS5600_ADDRESS, 2);
  readings[0] = (wire.available() >= 2) ? (wire.read() << 8) | wire.read() : 0;
  
  delayMicroseconds(100);
  
  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_RAW_ANGLE_REG);
  wire.endTransmission();
  wire.requestFrom(AS5600_ADDRESS, 2);
  readings[1] = (wire.available() >= 2) ? (wire.read() << 8) | wire.read() : 0;
  
  delayMicroseconds(100);

  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_RAW_ANGLE_REG);
  wire.endTransmission();
  wire.requestFrom(AS5600_ADDRESS, 2);
  readings[2] = (wire.available() >= 2) ? (wire.read() << 8) | wire.read() : 0;

  insertionSort(readings, 3);
  return readings[1]; // Return median value
}


bool detectAS5600Magnet(SoftwareWire &wire) {
  wire.beginTransmission(AS5600_ADDRESS);
  wire.write(AS5600_STATUS_REG);
  if (wire.endTransmission() != 0) return false;
  wire.requestFrom(AS5600_ADDRESS, 1);
  if (wire.available()) {
    uint8_t status = wire.read();
    return (status & 0x20) != 0; // Check MD bit
  }
  return false;
}

float normalizeAngle(float angle) {
  while (angle > 180.0) angle -= 360.0;
  while (angle < -180.0) angle += 360.0;
  return angle;
}

// BUGFIX #2: Handle angle wraparound for derivative calculation
float normalizeAngleDelta(float delta) {
  while (delta > 180.0f) delta -= 360.0f;
  while (delta < -180.0f) delta += 360.0f;
  return delta;
}

void updateSensors() {
  // BUGFIX #3: Use median filter for robust EMI rejection
  pendulumRaw = readAngleMedian(as5600_pendulum);
  float pendulum_deg = (pendulumRaw * 360.0) / 4096.0;
  pendulumAngle = normalizeAngle(pendulum_deg - pendulumZeroAngle);
  
  motorRaw = readAngleMedian(motorWire);
  float motor_deg = (motorRaw * 360.0) / 4096.0;
  motorAngle = normalizeAngle(motor_deg - motorZeroAngle);
}

// ============================================================
//  STARTUP DIAGNOSTICS
// ============================================================

bool checkSystemHealth() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║      SYSTEM DIAGNOSTICS                    ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  
  bool allGood = true;
  
  // Check motor driver
  Serial.print("Motor Driver... ");
  digitalWrite(EN_PIN, LOW);
  delay(100);
  Serial.println("✓ Enabled");
  
  // Check pendulum sensor
  Serial.print("Pendulum Sensor (Hardware I2C 0x36)... ");
  if (!as5600_pendulum.detectMagnet()) {
    Serial.println("✗ FAILED - No magnet detected!");
    allGood = false;
  } else {
    // BUGFIX #3: Use median read in diagnostics
    uint16_t raw = readAngleMedian(as5600_pendulum);
    Serial.print("✓ OK (raw: ");
    Serial.print(raw);
    Serial.println(")");
  }
  
  // Check motor sensor
  Serial.print("Motor Sensor (Software I2C 0x36)... ");
  if (!detectAS5600Magnet(motorWire)) {
    Serial.println("✗ FAILED - No magnet detected!");
    allGood = false;
  } else {
    // BUGFIX #3: Use median read in diagnostics
    uint16_t raw = readAngleMedian(motorWire);
    Serial.print("✓ OK (raw: ");
    Serial.print(raw);
    Serial.println(")");
  }
  
  // Test motor movement
  Serial.print("Motor Movement Test... ");
  long startPos = stepper.currentPosition();
  stepper.setMaxSpeed(1000); // Use a known speed
  stepper.moveTo(startPos + 200); // Move 200 steps
  // BUGFIX #1: Call run() continuously
  while(stepper.distanceToGo() != 0) {
    stepper.run();
  }
  stepper.moveTo(startPos); // Move back
  while(stepper.distanceToGo() != 0) {
    stepper.run();
  }
  stepper.setCurrentPosition(startPos); // Reset
  Serial.println("✓ Motor responds");
  
  Serial.println();
  if (allGood) {
    Serial.println("✅ ALL SYSTEMS OPERATIONAL");
  } else {
    Serial.println("❌ SYSTEM CHECK FAILED - Fix errors before proceeding");
  }
  Serial.println("════════════════════════════════════════════\n");
  
  return allGood;
}

// ============================================================
//  ZEROING PROCEDURE
// ============================================================

void performZeroing() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║      ZERO POSITION SETUP                   ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  Serial.println("IMPROVED ZEROING with motor positioning:");
  Serial.println("1. Use A/D keys to jog motor LEFT/RIGHT");
  Serial.println("2. Position arm at mechanical CENTER");
  Serial.println("3. Hold pendulum STRAIGHT UP (vertical)");
  Serial.println("4. Press 'Z' to set zero position\n");
  
  currentState = STATE_ZEROING;
  digitalWrite(EN_PIN, LOW); // Enable motor
  stepper.setMaxSpeed(JOG_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  
  unsigned long lastPrint = millis();
  
  while (true) {
    stepper.run();
    
    // Display current sensor readings
    if (millis() - lastPrint >= 300) {
      lastPrint = millis();
      uint16_t motor_raw = readAngleMedian(motorWire);
      float motor_deg = (motor_raw * 360.0) / 4096.0;
      Serial.print("Motor raw: ");
      Serial.print(motor_raw);
      Serial.print(" | Motor: ");
      Serial.print(motor_deg, 2);
      Serial.print("° | Steps: ");
      Serial.println(stepper.currentPosition());
    }
    
    if (Serial.available() > 0) {
      char c = Serial.read();
      
      if (c == 'a' || c == 'A') {
        // Jog left
        stepper.move(-50);
        while (stepper.distanceToGo() != 0) {
          stepper.run();
        }
        Serial.println("← Jogged left");
        
      } else if (c == 'd' || c == 'D') {
        // Jog right
        stepper.move(50);
        while (stepper.distanceToGo() != 0) {
          stepper.run();
        }
        Serial.println("→ Jogged right");
        
      } else if (c == 'z' || c == 'Z') {
        // Set zero positions
        stepper.setCurrentPosition(0);
        stepsAtZero = 0;
        
        // BUGFIX #3: Use median read
        uint16_t pendulum_raw = readAngleMedian(as5600_pendulum);
        pendulumZeroAngle = (pendulum_raw * 360.0) / 4096.0;
        
        uint16_t motor_raw = readAngleMedian(motorWire);
        motorZeroAngle = (motor_raw * 360.0) / 4096.0;
        
        Serial.println("\n✅ ZERO POSITION SET!");
        Serial.print("   Pendulum zero: ");
        Serial.print(pendulumZeroAngle, 2);
        Serial.print("° (raw: ");
        Serial.print(pendulum_raw);
        Serial.println(")");
        Serial.print("   Motor zero: ");
        Serial.print(motorZeroAngle, 2);
        Serial.print("° (raw: ");
        Serial.print(motor_raw);
        Serial.println(")");
        Serial.print("   Step position: ");
        Serial.println(stepsAtZero);
        Serial.println("════════════════════════════════════════════\n");
        
        // Initialize previousPendulumAngle to avoid derivative spike
        updateSensors();
        previousPendulumAngle = pendulumAngle;
        
        digitalWrite(EN_PIN, HIGH); // Disable motor
        currentState = STATE_IDLE;
        break;
      }
    }
  }
}

// ============================================================
//  SENSOR LIVE MONITORING
// ============================================================

void liveMonitorSensors() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║      LIVE SENSOR MONITORING                ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  Serial.println("Streaming both sensors. Press 'S' to stop.\n");
  Serial.println("────────────────────────────────────────────────");
  Serial.println("Pendulum(°) | Motor(°) | Motor Raw | Steps");
  Serial.println("────────────────────────────────────────────────");
  
  unsigned long lastPrint = millis();
  
  while (true) {
    if (Serial.available() > 0) {
      char c = Serial.read();
      if (c == 's' || c == 'S') {
        Serial.println("────────────────────────────────────────────────");
        Serial.println("\nMonitoring stopped.\n");
        return;
      }
    }
    
    if (millis() - lastPrint >= 200) {
      lastPrint = millis();
      updateSensors();
      
      Serial.print("  ");
      Serial.print(pendulumAngle, 2);
      Serial.print("°   \t");
      Serial.print(motorAngle, 2);
      Serial.print("°  \t");
      Serial.print(motorRaw);
      Serial.print("  \t");
      Serial.println(stepper.currentPosition());
    }
  }
}

// ============================================================
//  LIMIT CALIBRATION
// ============================================================

void calibrateLimits() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║      LIMIT CALIBRATION                     ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  Serial.println("Use A/D keys to jog left/right");
  Serial.println("Press 'L' at LEFT limit, 'R' at RIGHT limit");
  Serial.println("Press 'Q' to quit calibration\n");
  
  currentState = STATE_CALIBRATION;
  digitalWrite(EN_PIN, LOW); // Enable motor for jogging
  stepper.setMaxSpeed(JOG_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  
  bool leftSet = false;
  bool rightSet = false;
  
  while (true) {
    // BUGFIX #1: Call stepper.run() continuously
    stepper.run();

    if (Serial.available() > 0) {
      char c = Serial.read();
      
      if (c == 'a' || c == 'A') {
        // Jog left
        stepper.move(-50);
        // Wait for move to complete
        while (stepper.distanceToGo() != 0) {
          stepper.run();
        }
        updateSensors();
        Serial.print("← Left | Motor: ");
        Serial.print(motorAngle, 2);
        Serial.print("° | Steps: ");
        Serial.println(stepper.currentPosition());
        
      } else if (c == 'd' || c == 'D') {
        // Jog right
        stepper.move(50);
        // Wait for move to complete
        while (stepper.distanceToGo() != 0) {
          stepper.run();
        }
        updateSensors();
        Serial.print("→ Right | Motor: ");
        Serial.print(motorAngle, 2);
        Serial.print("° | Steps: ");
        Serial.println(stepper.currentPosition());
        
      } else if (c == 'l' || c == 'L') {
        // Set left limit
        updateSensors();
        motorLeftLimit = motorAngle;
        stepsAtLeftLimit = stepper.currentPosition();
        leftSet = true;
        Serial.print("\n✓ LEFT LIMIT SET: ");
        Serial.print(motorLeftLimit, 2);
        Serial.print("° (");
        Serial.print(stepsAtLeftLimit);
        Serial.println(" steps)\n");
        
      } else if (c == 'r' || c == 'R') {
        // Set right limit
        updateSensors();
        motorRightLimit = motorAngle;
        stepsAtRightLimit = stepper.currentPosition();
        rightSet = true;
        Serial.print("\n✓ RIGHT LIMIT SET: ");
        Serial.print(motorRightLimit, 2);
        Serial.print("° (");
        Serial.print(stepsAtRightLimit);
        Serial.println(" steps)\n");
        
      } else if (c == 'q' || c == 'Q') {
        if (leftSet && rightSet) {
          systemCalibrated = true;
          digitalWrite(EN_PIN, HIGH); // Disable motor after calibration
          Serial.println("\n✅ CALIBRATION COMPLETE!");
          Serial.print("   Range: ");
          Serial.print(motorRightLimit - motorLeftLimit, 1);
          Serial.print("° (");
          Serial.print(stepsAtRightLimit - stepsAtLeftLimit);
          Serial.println(" steps)");
          Serial.println("════════════════════════════════════════════\n");
          currentState = STATE_IDLE;
          return;
        } else {
          Serial.println("\n⚠ Must set both LEFT and RIGHT limits before quitting!\n");
        }
      }
    }
  }
}

// ============================================================
//  RETURN TO CENTER
// ============================================================

void returnToCenter() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║      RETURNING TO CENTER                   ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  
  Serial.print("Current position: ");
  Serial.print(stepper.currentPosition());
  Serial.println(" steps");
  Serial.print("Target (stepsAtZero): ");
  Serial.print(stepsAtZero);
  Serial.println(" steps");
  Serial.print("Distance to go: ");
  Serial.print(stepper.currentPosition() - stepsAtZero);
  Serial.println(" steps");
  
  digitalWrite(EN_PIN, LOW); // Enable motor
  stepper.setMaxSpeed(MOTOR_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  stepper.moveTo(stepsAtZero);
  
  // BUGFIX #1: Call stepper.run() continuously
  while (stepper.distanceToGo() != 0) {
    stepper.run();
  }
  
  delay(100); // Let motor settle
  digitalWrite(EN_PIN, HIGH); // Disable motor
  updateSensors();
  
  Serial.println();
  Serial.print("✓ Arrived at: ");
  Serial.print(stepper.currentPosition());
  Serial.println(" steps");
  Serial.print("  Motor angle (sensor): ");
  Serial.print(motorAngle, 2);
  Serial.println("°");
  Serial.print("  Motor raw reading: ");
  Serial.println(motorRaw);
  Serial.print("  Motor zero angle: ");
  Serial.print(motorZeroAngle, 2);
  Serial.println("°");
  
  float angleError = abs(motorAngle);
  if (angleError > 5.0) {
    Serial.println("\n⚠ WARNING: Significant position error detected!");
    Serial.print("  Error: ");
    Serial.print(angleError, 1);
    Serial.println("°");
    Serial.println("  Possible causes:");
    Serial.println("  - Missed steps during movement");
    Serial.println("  - Incorrect zero calibration");
    Serial.println("  - Sensor magnetic field issue");
    Serial.println("\n  Try this fix:");
    Serial.println("  1. Move motor to actual center position (use option 3)");
    Serial.println("  2. When sensor reads close to 0°, press 'Z' in zeroing");
    Serial.println("  3. Or use option 4 to jog to center, then re-zero");
  }
  Serial.println("════════════════════════════════════════════\n");
}

// ============================================================
//  CONTROL SYSTEM - BANG-BANG SWING-UP
// ============================================================

void runSwingUp() {
  updateSensors();
  
  // BUGFIX #2: Use normalized delta for velocity
  float angleDelta = normalizeAngleDelta(pendulumAngle - previousPendulumAngle);
  // Convert delta to rad/s
  float alpha_dot = (angleDelta * DEG2RAD) / (CONTROL_LOOP_MS / 1000.0);
  
  previousPendulumAngle = pendulumAngle;
  
  // Check if ready to switch to BALANCE (near upright AND slow)
  // 2.0 rad/s is ~115 deg/s
  if (abs(pendulumAngle) < balanceThreshold && abs(alpha_dot) < 2.0) {
    Serial.println("\n✓ Pendulum near upright & slow - Switching to BALANCE mode");
    currentState = STATE_BALANCE;
    integralError = 0.0;
    lastControlTime = millis();
    // previousPendulumAngle is already set
    return;
  }
  
  // Bang-bang control: pump energy
  float u; // control in steps
  float alpha_rad = pendulumAngle * DEG2RAD;
  if (alpha_dot * cos(alpha_rad) > 0) {
    // Moving away from upright → push in same direction to add energy
    u = +Kp_swing;
  } else {
    // Moving toward upright → back off / brake
    u = -Kp_swing;
  }
  
  long targetSteps = stepper.currentPosition() + (long)u;
  
  // Enforce limits
  if (targetSteps < stepsAtLeftLimit) targetSteps = stepsAtLeftLimit;
  if (targetSteps > stepsAtRightLimit) targetSteps = stepsAtRightLimit;
  
  stepper.moveTo(targetSteps);
  // stepper.run() is called in main loop
}

// ============================================================
//  CONTROL SYSTEM - PID BALANCE
// ============================================================

void runBalance() {
  updateSensors();
  
  // Use fixed dt for consistent control
  const float dt = CONTROL_LOOP_MS / 1000.0;  // 0.01s
  
  // Check if pendulum fell
  if (abs(pendulumAngle) > 60.0) {
    Serial.println("\n⚠ Pendulum fell - Returning to IDLE");
    stepper.stop();
    currentState = STATE_IDLE;
    return;
  }
  
  // PID control on pendulum angle
  float error = pendulumAngle; // Want it at 0°
  integralError += error * dt;
  
  // Anti-windup
  if (integralError > 100.0) integralError = 100.0;
  if (integralError < -100.0) integralError = -100.0;
  
  // BUGFIX #2: Use normalized delta for velocity
  float angleDelta = normalizeAngleDelta(pendulumAngle - previousPendulumAngle);
  float derivative = angleDelta / dt;
  
  previousPendulumAngle = pendulumAngle;
  
  float pidOutput = Kp_balance * error + Ki_balance * integralError + Kd_balance * derivative;
  
  // Also include motor position feedback (keep centered)
  float motorCorrection = -0.5 * motorAngle;
  
  float totalControl = pidOutput + motorCorrection;
  
  // Convert to target position with proper scaling
  long targetSteps = stepsAtZero - (long)(totalControl * balanceScale);
  
  // Enforce limits
  if (targetSteps < stepsAtLeftLimit) targetSteps = stepsAtLeftLimit;
  if (targetSteps > stepsAtRightLimit) targetSteps = stepsAtRightLimit;
  
  stepper.moveTo(targetSteps);
  // stepper.run() is called in main loop
}


// ============================================================
//  MAIN MENU & CONTROL TICK
// ============================================================

void printMenu() {
  Serial.println("\n╔════════════════════════════════════════════╗");
  Serial.println("║  ROTARY INVERTED PENDULUM CONTROL         ║");
  Serial.println("╚════════════════════════════════════════════╝");
  Serial.print("\nState: ");
  switch(currentState) {
    case STATE_STARTUP: Serial.println("STARTUP"); break;
    case STATE_ZEROING: Serial.println("ZEROING"); break;
    case STATE_CALIBRATION: Serial.println("CALIBRATION"); break;
    case STATE_IDLE: Serial.println("IDLE"); break;
    case STATE_SWING_UP: Serial.println("SWING-UP ACTIVE"); break;
    case STATE_BALANCE: Serial.println("BALANCING"); break;
    case STATE_EMERGENCY_STOP: Serial.println("EMERGENCY STOP"); break;
  }
  Serial.print("Calibrated: ");
  Serial.println(systemCalibrated ? "YES" : "NO");
  Serial.println("\n--- SETUP SEQUENCE ---");
  Serial.println("1 - System Diagnostics");
  Serial.println("2 - Set Zero Position");
  Serial.println("3 - Live Sensor Monitoring");
  Serial.println("4 - Calibrate Left/Right Limits");
  Serial.println("5 - Return to Center");
  Serial.println("\n--- CONTROL ---");
  Serial.println("S - Start Swing-Up & Balance");
  Serial.println("B - Balance Test (manual start from upright)");
  Serial.println("X - Stop Control");
  Serial.println("E - Emergency Stop");
  Serial.println("════════════════════════════════════════════");
  Serial.print("Choice: ");
}

// BUGFIX #1: New function to run control logic at a fixed rate
void controlTick() {
  // This function is called every 10ms by the timer in loop()
  if (currentState == STATE_SWING_UP) {
    runSwingUp();
  } else if (currentState == STATE_BALANCE) {
    runBalance();
  }
}

// ============================================================
//  SETUP
// ============================================================

void setup() {
  // Initialize pins
  pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, HIGH); // Disabled initially
  pinMode(STEP_PIN, OUTPUT);
  digitalWrite(STEP_PIN, LOW);
  pinMode(DIR_PIN, OUTPUT);
  digitalWrite(DIR_PIN, LOW);
  
  // Initialize serial
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("\n\n╔════════════════════════════════════════════╗");
  Serial.println("║  ROTARY INVERTED PENDULUM - FULL SYSTEM   ║");
  Serial.println("║  Sensor-Based Calibration & Control (v3)  ║");
  Serial.println("╚════════════════════════════════════════════╝\n");
  
  // Configure stepper
  stepper.setMaxSpeed(MOTOR_SPEED);
  stepper.setAcceleration(MOTOR_ACCEL);
  stepper.setCurrentPosition(0);
  
  // Initialize Hardware I2C (pendulum sensor)
  Wire.begin();
  Wire.setClock(100000); // 100kHz for noise robustness
  delay(100);
  as5600_pendulum.begin();
  
  // Initialize Software I2C (motor sensor)
  motorWire.begin();
  motorWire.setClock(100000); // 100kHz for noise robustness
  delay(100);
  
  Serial.println("System initialized. Run diagnostics (option 1) first.\n");
  
  currentState = STATE_STARTUP;
  printMenu();
}

// ============================================================
//  MAIN LOOP
// ============================================================

void loop() {
  // BUGFIX #1: Main loop must run as fast as possible
  // Call stepper.run() continuously
  if (currentState == STATE_SWING_UP || currentState == STATE_BALANCE) {
    stepper.run();
  }

  // Handle control logic at a fixed rate (100Hz)
  unsigned long now = millis();
  if (now - lastControlTime >= CONTROL_LOOP_MS) {
    lastControlTime = now;
    if (currentState == STATE_SWING_UP || currentState == STATE_BALANCE) {
      controlTick();
    }
  }

  // Handle serial commands (non-blocking)
  if (Serial.available() > 0) {
    char c = Serial.read();
    
    if (c == '\n' || c == '\r') return;
    
    // Stop commands should be checked first, even during control
    if (c == 'x' || c == 'X') {
        stepper.stop(); // stop() is OK for moveTo() mode
        currentState = STATE_IDLE;
        digitalWrite(EN_PIN, HIGH); // Disable motor
        Serial.println("\n✓ Control stopped");
        printMenu();
        return;
    }
    if (c == 'e' || c == 'E') {
        stepper.stop();
        digitalWrite(EN_PIN, HIGH);
        currentState = STATE_EMERGENCY_STOP;
        Serial.println("\n!!! EMERGENCY STOP !!!");
        Serial.println("Power cycle or reset to continue.\n");
        return;
    }

    // Menu handling (only if not in an active control state)
    if (currentState != STATE_SWING_UP && currentState != STATE_BALANCE) {
      switch(c) {
        case '1':
          checkSystemHealth();
          printMenu();
          break;
          
        case '2':
          performZeroing();
          printMenu();
          break;
          
        case '3':
          liveMonitorSensors();
          printMenu();
          break;
          
        case '4':
          if (currentState != STATE_IDLE && currentState != STATE_CALIBRATION) {
            Serial.println("\nMust be in IDLE state. Set zero position first (option 2).\n");
          } else {
            calibrateLimits();
          }
          printMenu();
          break;
          
        case '5':
          if (!systemCalibrated) {
            Serial.println("\nMust calibrate limits first (option 4).\n");
          } else {
            returnToCenter();
          }
          printMenu();
          break;
          
        case 's': case 'S':
          if (!systemCalibrated) {
            Serial.println("\n⚠ Cannot start - System not calibrated!");
            Serial.println("Complete setup sequence (options 1-5) first.\n");
            printMenu();
          } else {
            Serial.println("\n╔════════════════════════════════════════════╗");
            Serial.println("║  STARTING SWING-UP CONTROL                 ║");
            Serial.println("╚════════════════════════════════════════════╝\n");
            Serial.println("Pull pendulum down, then release...");
            Serial.println("Press 'X' to stop.\n");
            digitalWrite(EN_PIN, LOW);
            updateSensors();
            previousPendulumAngle = pendulumAngle;  // Initialize to current angle
            delay(1000);
            currentState = STATE_SWING_UP;
            lastControlTime = millis();
          }
          break;

        case 'b': case 'B':
          if (!systemCalibrated) {
            Serial.println("\n⚠ Cannot start - System not calibrated!");
            Serial.println("Complete setup sequence (options 1-5) first.\n");
            printMenu();
          } else {
            Serial.println("\n╔════════════════════════════════════════════╗");
            Serial.println("║  BALANCE TEST MODE                         ║");
            Serial.println("╚════════════════════════════════════════════╝\n");
            Serial.println("Hold pendulum near upright, then release...");
            Serial.println("Press 'X' to stop.\n");
            digitalWrite(EN_PIN, LOW);
            updateSensors();
            previousPendulumAngle = pendulumAngle;
            integralError = 0.0;
            delay(1000);
            currentState = STATE_BALANCE;
            lastControlTime = millis();
          }
          break;
          
        case 'x': case 'X': // This case is redundant here but harmless
          stepper.stop();
          currentState = STATE_IDLE;
          Serial.println("\n✓ Stopped");
          printMenu();
          break;
          
        case 'e': case 'E': // This case is redundant here but harmless
          stepper.stop();
          digitalWrite(EN_PIN, HIGH);
          currentState = STATE_EMERGENCY_STOP;
          Serial.println("\n!!! EMERGENCY STOP !!!");
          Serial.println("Power cycle or reset to continue.\n");
          break;
          
        default:
          if (c != '\n' && c != '\r') {
            Serial.println("\nInvalid choice.");
            printMenu();
          }
          break;
      }
    }
  }
}